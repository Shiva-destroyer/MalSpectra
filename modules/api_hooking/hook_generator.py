"""
MalSpectra - API Hook Generator
Generates LD_PRELOAD hooks for Linux function interposition

Developer: Sai Srujan Murthy
Email: saisrujanmurthy@gmail.com
"""

import subprocess
from pathlib import Path
from typing import Dict, Optional


class HookGenerator:
    """
    Generates C code for LD_PRELOAD hooks and compiles to .so
    """
    
    # Common functions to hook with their signatures
    HOOKABLE_FUNCTIONS = {
        'fopen': {
            'signature': 'FILE* fopen(const char *pathname, const char *mode)',
            'return_type': 'FILE*',
            'params': 'const char *pathname, const char *mode',
            'param_names': 'pathname, mode',
            'log_format': '"[HOOKED] fopen called: %s (mode: %s)\\n", pathname, mode',
            'includes': ['<stdio.h>', '<dlfcn.h>']
        },
        'fclose': {
            'signature': 'int fclose(FILE *stream)',
            'return_type': 'int',
            'params': 'FILE *stream',
            'param_names': 'stream',
            'log_format': '"[HOOKED] fclose called: %p\\n", stream',
            'includes': ['<stdio.h>', '<dlfcn.h>']
        },
        'write': {
            'signature': 'ssize_t write(int fd, const void *buf, size_t count)',
            'return_type': 'ssize_t',
            'params': 'int fd, const void *buf, size_t count',
            'param_names': 'fd, buf, count',
            'log_format': '"[HOOKED] write called: fd=%d, count=%zu\\n", fd, count',
            'includes': ['<unistd.h>', '<dlfcn.h>', '<sys/types.h>']
        },
        'read': {
            'signature': 'ssize_t read(int fd, void *buf, size_t count)',
            'return_type': 'ssize_t',
            'params': 'int fd, void *buf, size_t count',
            'param_names': 'fd, buf, count',
            'log_format': '"[HOOKED] read called: fd=%d, count=%zu\\n", fd, count',
            'includes': ['<unistd.h>', '<dlfcn.h>', '<sys/types.h>']
        },
        'connect': {
            'signature': 'int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)',
            'return_type': 'int',
            'params': 'int sockfd, const struct sockaddr *addr, socklen_t addrlen',
            'param_names': 'sockfd, addr, addrlen',
            'log_format': '"[HOOKED] connect called: sockfd=%d\\n", sockfd',
            'includes': ['<sys/socket.h>', '<dlfcn.h>']
        },
        'socket': {
            'signature': 'int socket(int domain, int type, int protocol)',
            'return_type': 'int',
            'params': 'int domain, int type, int protocol',
            'param_names': 'domain, type, protocol',
            'log_format': '"[HOOKED] socket called: domain=%d, type=%d, protocol=%d\\n", domain, type, protocol',
            'includes': ['<sys/socket.h>', '<dlfcn.h>']
        },
        'open': {
            'signature': 'int open(const char *pathname, int flags, ...)',
            'return_type': 'int',
            'params': 'const char *pathname, int flags, ...',
            'param_names': 'pathname, flags',
            'log_format': '"[HOOKED] open called: %s (flags: 0x%x)\\n", pathname, flags',
            'includes': ['<fcntl.h>', '<dlfcn.h>', '<stdarg.h>']
        },
        'malloc': {
            'signature': 'void* malloc(size_t size)',
            'return_type': 'void*',
            'params': 'size_t size',
            'param_names': 'size',
            'log_format': '"[HOOKED] malloc called: size=%zu\\n", size',
            'includes': ['<stdlib.h>', '<dlfcn.h>']
        }
    }
    
    def __init__(self):
        """Initialize hook generator."""
        self.hooks = {}
    
    def generate_hook_code(self, function_name: str) -> Optional[str]:
        """
        Generate C code for hooking a specific function.
        
        Args:
            function_name: Name of function to hook
            
        Returns:
            C source code as string
        """
        if function_name not in self.HOOKABLE_FUNCTIONS:
            return None
        
        func_info = self.HOOKABLE_FUNCTIONS[function_name]
        
        # Build includes
        includes = '\n'.join(f'#include {inc}' for inc in func_info['includes'])
        
        # Special handling for functions with variadic args
        if '...' in func_info['params']:
            # For 'open' function
            code = f"""// Auto-generated LD_PRELOAD hook for {function_name}
// Generated by MalSpectra - Sai Srujan Murthy

#define _GNU_SOURCE
{includes}

typedef {func_info['return_type']} (*original_{function_name}_t)({func_info['params']});

{func_info['return_type']} {function_name}({func_info['params']}) {{
    original_{function_name}_t original_{function_name};
    original_{function_name} = (original_{function_name}_t)dlsym(RTLD_NEXT, "{function_name}");
    
    // Log the hook
    fprintf(stderr, {func_info['log_format']});
    
    // Handle variadic args for open()
    mode_t mode = 0;
    if (flags & O_CREAT) {{
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
        return original_{function_name}(pathname, flags, mode);
    }}
    
    // Call original function
    return original_{function_name}({func_info['param_names']});
}}
"""
        else:
            # Standard function hooking template
            code = f"""// Auto-generated LD_PRELOAD hook for {function_name}
// Generated by MalSpectra - Sai Srujan Murthy

#define _GNU_SOURCE
{includes}

typedef {func_info['return_type']} (*original_{function_name}_t)({func_info['params']});

{func_info['return_type']} {function_name}({func_info['params']}) {{
    original_{function_name}_t original_{function_name};
    original_{function_name} = (original_{function_name}_t)dlsym(RTLD_NEXT, "{function_name}");
    
    // Log the hook
    fprintf(stderr, {func_info['log_format']});
    
    // Call original function
    return original_{function_name}({func_info['param_names']});
}}
"""
        
        return code
    
    def compile_hook(self, source_code: str, output_name: str = "hook.so") -> bool:
        """
        Compile C source code to shared library.
        
        Args:
            source_code: C source code
            output_name: Output .so filename
            
        Returns:
            True if compilation successful, False otherwise
        """
        # Create temporary source file
        source_file = Path("hook_temp.c")
        source_file.write_text(source_code)
        
        # Compile command
        output_path = Path(output_name)
        compile_cmd = [
            'gcc',
            '-shared',
            '-fPIC',
            '-o', str(output_path),
            str(source_file),
            '-ldl'
        ]
        
        try:
            result = subprocess.run(
                compile_cmd,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            # Clean up source file
            source_file.unlink()
            
            if result.returncode == 0:
                return True
            else:
                print(f"Compilation error: {result.stderr}")
                return False
        
        except subprocess.TimeoutExpired:
            source_file.unlink()
            print("Compilation timed out")
            return False
        
        except FileNotFoundError:
            source_file.unlink()
            print("Error: gcc not found. Please install gcc.")
            return False
        
        except Exception as e:
            source_file.unlink()
            print(f"Compilation error: {e}")
            return False
    
    def get_available_functions(self) -> list:
        """
        Get list of available functions to hook.
        
        Returns:
            List of function names
        """
        return sorted(self.HOOKABLE_FUNCTIONS.keys())


if __name__ == "__main__":
    # Test hook generator
    generator = HookGenerator()
    
    print("Available functions to hook:")
    for func in generator.get_available_functions():
        print(f"  - {func}")
    
    print("\nGenerating hook for 'fopen'...")
    code = generator.generate_hook_code('fopen')
    
    if code:
        print("\nGenerated code:")
        print(code)
        
        print("\nCompiling...")
        if generator.compile_hook(code, "fopen_hook.so"):
            print("Success! Use with: LD_PRELOAD=./fopen_hook.so ./target")
        else:
            print("Compilation failed")
    else:
        print("Failed to generate code")
