# Module 5: API Hooking Framework

## Overview

The API Hooking Framework generates LD_PRELOAD-based function hooks for Linux systems. It creates C code that intercepts function calls in dynamically linked executables, allowing you to monitor and analyze program behavior at the API level.

**Developer**: Sai Srujan Murthy  
**Email**: saisrujanmurthy@gmail.com  
**Status**: Production Ready ✅

---

## Features

- **8 Hookable Functions**: File I/O, network, memory operations
- **Automatic C Code Generation**: Template-based code creation
- **GCC Integration**: Automatic compilation to `.so` files
- **Syntax Highlighting**: Rich code display
- **Usage Instructions**: Complete command examples
- **LD_PRELOAD Method**: Standard Linux function interposition

---

## Technical Details

### Components

#### 1. hook_generator.py (HookGenerator Class)

**Purpose**: Generate and compile function hooks

**Hookable Functions**:

| Function | Category | Purpose |
|----------|----------|---------|
| `fopen` | File I/O | Open files |
| `fclose` | File I/O | Close files |
| `open` | File I/O | Low-level file open |
| `read` | File I/O | Read data |
| `write` | File I/O | Write data |
| `socket` | Network | Create socket |
| `connect` | Network | Connect to address |
| `malloc` | Memory | Allocate memory |

**Key Methods**:

- `generate_hook_code(function_name)`:
  - Selects function template
  - Generates C code with proper signatures
  - Includes dlsym for original function resolution
  - Returns complete C source code

- `compile_hook(source_code, output_name)`:
  - Writes temporary C file
  - Calls gcc with flags: `-shared -fPIC -ldl`
  - Compiles to `.so` shared library
  - Returns success/failure status

- `get_available_functions()`:
  - Returns sorted list of hookable functions

#### 2. main.py (User Interface)

**Purpose**: Interactive hook generation workflow

**Workflow**:
1. Display module banner
2. Check for gcc availability
3. Show available functions in table
4. User selects function to hook
5. User specifies output filename
6. Generate C code with syntax highlighting
7. Confirm compilation
8. Compile to `.so` file
9. Display usage instructions

---

## LD_PRELOAD Mechanism

### How It Works

**LD_PRELOAD** is a Linux environment variable that forces the dynamic linker to load specified libraries before any others. This allows you to:

1. **Override Functions**: Your implementation runs instead of the original
2. **Call Original**: Use `dlsym(RTLD_NEXT, ...)` to get the original function
3. **Log Behavior**: Print to stderr before calling original
4. **Transparent**: Target program is unaware of hooking

### Hook Flow

```
Application calls fopen()
   ↓
Dynamic linker checks LD_PRELOAD
   ↓
Your hook function executes
   ↓
Hook logs call to stderr
   ↓
Hook calls dlsym(RTLD_NEXT, "fopen")
   ↓
Original fopen() executes
   ↓
Return value passed back to application
```

---

## Generated Code Structure

### Template Example (fopen)

```c
// Auto-generated LD_PRELOAD hook for fopen
// Generated by MalSpectra - Sai Srujan Murthy

#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>

typedef FILE* (*original_fopen_t)(const char *pathname, const char *mode);

FILE* fopen(const char *pathname, const char *mode) {
    original_fopen_t original_fopen;
    original_fopen = (original_fopen_t)dlsym(RTLD_NEXT, "fopen");
    
    // Log the hook
    fprintf(stderr, "[HOOKED] fopen called: %s (mode: %s)\n", pathname, mode);
    
    // Call original function
    return original_fopen(pathname, mode);
}
```

### Key Elements

1. **`#define _GNU_SOURCE`**: Enable GNU extensions for RTLD_NEXT
2. **Type Definition**: `typedef` for original function pointer
3. **dlsym()**: Resolve original function at runtime
4. **RTLD_NEXT**: Find next occurrence of symbol in library chain
5. **fprintf(stderr, ...)**: Log to stderr (not buffered)
6. **Return original result**: Transparent to caller

---

## Usage

### Basic Workflow

```bash
# 1. Run MalSpectra
python3 main.py

# 2. Select Module 5 (API Hooking)

# 3. Choose function (e.g., fopen)
Select function: 1

# 4. Set output filename
Output: fopen_hook.so

# 5. Confirm compilation
Compile? y

# 6. Use generated hook
LD_PRELOAD=./fopen_hook.so /target/program
```

### Example Session

```
═══ AVAILABLE FUNCTIONS ═══

┏━━━┳━━━━━━━━━━┳━━━━━━━━━┓
┃ # ┃ Function ┃ Category┃
┡━━━╇━━━━━━━━━━╇━━━━━━━━━┩
│ 1 │ fopen    │ File I/O│
│ 2 │ write    │ File I/O│
│ 3 │ socket   │ Network │
└───┴──────────┴─────────┘

Select function: 1
✓ Selected function: fopen

Output filename: fopen_hook.so
✓ Output file: fopen_hook.so

═══ GENERATED HOOK CODE ═══

[C code with syntax highlighting...]

Compile? y

✓ Hook compiled successfully!
✓ Output: fopen_hook.so

═══ How to Use This Hook ═══

1. Basic Usage:
   LD_PRELOAD=./fopen_hook.so /path/to/target

2. With Python:
   LD_PRELOAD=./fopen_hook.so python3 script.py

3. Check Output:
   LD_PRELOAD=./fopen_hook.so ./target 2> hooks.log
```

---

## Compilation Process

### GCC Command

```bash
gcc -shared -fPIC -o hook.so hook.c -ldl
```

**Flags**:
- `-shared`: Create shared library
- `-fPIC`: Position Independent Code (required for .so)
- `-o hook.so`: Output filename
- `-ldl`: Link against libdl (for dlsym)

### Requirements

```bash
# Debian/Ubuntu
sudo apt install build-essential

# RHEL/CentOS
sudo yum install gcc

# Arch Linux
sudo pacman -S gcc
```

---

## Real-World Examples

### Example 1: Monitor File Access

```bash
# Generate fopen hook
# Output: fopen_hook.so

# Run SSH client with hook
LD_PRELOAD=./fopen_hook.so ssh user@host

# Output (stderr):
[HOOKED] fopen called: /etc/ssh/ssh_config (mode: r)
[HOOKED] fopen called: ~/.ssh/known_hosts (mode: r)
[HOOKED] fopen called: ~/.ssh/id_rsa (mode: r)
```

### Example 2: Network Monitoring

```bash
# Generate connect hook
# Output: connect_hook.so

# Run web client
LD_PRELOAD=./connect_hook.so curl https://example.com

# Output (stderr):
[HOOKED] connect called: sockfd=3
```

### Example 3: Memory Profiling

```bash
# Generate malloc hook
# Output: malloc_hook.so

# Run application
LD_PRELOAD=./malloc_hook.so ./myapp

# Output (stderr):
[HOOKED] malloc called: size=1024
[HOOKED] malloc called: size=4096
[HOOKED] malloc called: size=256
```

### Example 4: Write Operations

```bash
# Generate write hook
# Output: write_hook.so

# Monitor writes
LD_PRELOAD=./write_hook.so python3 data/test_target.py 2> write.log

# View log
cat write.log
[HOOKED] write called: fd=1, count=28
[HOOKED] write called: fd=1, count=24
```

---

## Use Cases

### 1. Malware Analysis
Monitor file/network operations of suspicious executables without modification.

### 2. Debugging
Track function calls during development to understand behavior.

### 3. Security Auditing
Identify what files/networks an application accesses.

### 4. Forensics
Capture API-level activity during incident investigation.

### 5. Reverse Engineering
Understand program behavior without source code.

### 6. Sandboxing
Create lightweight sandboxes by intercepting dangerous operations.

---

## Advanced Techniques

### Multiple Hooks

```bash
# Compile multiple hooks
fopen_hook.so
write_hook.so
connect_hook.so

# Load all at once (colon-separated)
LD_PRELOAD=./fopen_hook.so:./write_hook.so:./connect_hook.so ./target
```

### Conditional Logging

Edit generated C code:

```c
FILE* fopen(const char *pathname, const char *mode) {
    original_fopen_t original_fopen;
    original_fopen = (original_fopen_t)dlsym(RTLD_NEXT, "fopen");
    
    // Only log .txt files
    if (strstr(pathname, ".txt") != NULL) {
        fprintf(stderr, "[HOOKED] fopen: %s\n", pathname, mode);
    }
    
    return original_fopen(pathname, mode);
}
```

### Parameter Modification

```c
int open(const char *pathname, int flags, ...) {
    original_open_t original_open;
    original_open = (original_open_t)dlsym(RTLD_NEXT, "open");
    
    fprintf(stderr, "[HOOKED] open: %s\n", pathname);
    
    // Force read-only mode
    flags &= ~O_WRONLY;
    flags &= ~O_RDWR;
    flags |= O_RDONLY;
    
    return original_open(pathname, flags);
}
```

### Return Value Interception

```c
ssize_t write(int fd, const void *buf, size_t count) {
    original_write_t original_write;
    original_write = (original_write_t)dlsym(RTLD_NEXT, "write");
    
    fprintf(stderr, "[HOOKED] write: fd=%d, count=%zu\n", fd, count);
    
    ssize_t result = original_write(fd, buf, count);
    
    fprintf(stderr, "[HOOKED] write returned: %zd\n", result);
    
    return result;
}
```

---

## Limitations

### Technical Limitations
- **Dynamically linked only**: Won't work with static binaries
- **No syscall bypass**: Direct syscalls bypass hooks
- **Namespace issues**: Symbol conflicts possible
- **Performance overhead**: Each call has interception cost

### Security Limitations
- **Not foolproof**: Advanced malware may detect hooks
- **Can be bypassed**: Direct syscalls, static linking, anti-debugging
- **Root detection**: Some programs check LD_PRELOAD

### Platform Limitations
- **Linux-specific**: Won't work on Windows (use Detours/EasyHook)
- **macOS different**: Uses DYLD_INSERT_LIBRARIES
- **Architecture-specific**: x86-64 focused

---

## Troubleshooting

### "gcc: command not found"
**Solution**: Install gcc (see Compilation Process section)

### "undefined symbol: dlsym"
**Solution**: Add `-ldl` flag during compilation

### "Hook doesn't trigger"
**Causes**:
1. Binary is statically linked
2. Function not called by target
3. Wrong LD_PRELOAD path

**Debug**:
```bash
# Check if binary is dynamic
file /path/to/binary
# Should say: dynamically linked

# Test hook with simple program
echo "int main() { fopen('test', 'r'); }" > test.c
gcc test.c -o test
LD_PRELOAD=./fopen_hook.so ./test
```

### "Permission denied"
**Solution**: 
```bash
chmod +x fopen_hook.so
```

### "Target crashes"
**Cause**: Hook code has bugs  
**Solution**: Check generated code, ensure proper return types

---

## Best Practices

### 1. Error Handling

```c
FILE* fopen(const char *pathname, const char *mode) {
    original_fopen_t original_fopen;
    original_fopen = (original_fopen_t)dlsym(RTLD_NEXT, "fopen");
    
    if (!original_fopen) {
        fprintf(stderr, "[ERROR] Failed to resolve fopen\n");
        return NULL;
    }
    
    fprintf(stderr, "[HOOKED] fopen: %s (%s)\n", pathname, mode);
    
    FILE *result = original_fopen(pathname, mode);
    
    if (!result) {
        fprintf(stderr, "[ERROR] fopen failed: %s\n", strerror(errno));
    }
    
    return result;
}
```

### 2. Thread Safety

For multi-threaded programs, add mutex locks:

```c
#include <pthread.h>

static pthread_mutex_t hook_mutex = PTHREAD_MUTEX_INITIALIZER;

FILE* fopen(const char *pathname, const char *mode) {
    pthread_mutex_lock(&hook_mutex);
    // ... hook code ...
    pthread_mutex_unlock(&hook_mutex);
    return result;
}
```

### 3. Performance

Minimize overhead in critical paths:

```c
// Cache original function pointer
static original_fopen_t original_fopen = NULL;

FILE* fopen(const char *pathname, const char *mode) {
    if (!original_fopen) {
        original_fopen = (original_fopen_t)dlsym(RTLD_NEXT, "fopen");
    }
    // ... rest of hook ...
}
```

---

## References

- **LD_PRELOAD**: https://man7.org/linux/man-pages/man8/ld.so.8.html
- **dlsym**: https://man7.org/linux/man-pages/man3/dlsym.3.html
- **Function Interposition**: https://www.linuxjournal.com/article/7795
- **Shared Libraries**: https://tldp.org/HOWTO/Program-Library-HOWTO/

---

**Developer**: Sai Srujan Murthy  
**Email**: saisrujanmurthy@gmail.com  
**Module**: API Hooking Framework  
**Version**: 1.0
